define('jab/ba/element', ['require','exports'], function (require,exports) {
	
	function Element (spec) {
		if (spec) {
			//this.init(spec);
		}
	}
	
	var self = {
		_move:true
	};
	
	self.init = function (spec) {
		if (spec) {
			for (var p in spec) {
				this[p] = spec[p];
			}
		}
		
		if (spec.angle !== undefined) {
			this.moveAngle(this.angle);
		}
	};
	
	self.stop = function () {
		this._move = false;
	};	
	
	self.moveTo = function (toX,toY) {
		var dx = toX - this.x,
			dy = toY - this.y;
			distance = Math.sqrt(dx*dx + dy*dy);
		
		this._move = true;
		this.moves = parseInt(distance/this.speed,10);
		this.toX = toX;
		this.toY = toY;
		
		if (this.moves) {
			this.speedX =  (this.toX-this.x)/this.moves;
			this.speedY =  (this.toY-this.y)/this.moves;
		}
	};
	
	self.moveAngle = function (angle) {
		this._move = true;
		this.angle = angle;
		this.updateSpeedComponents();
	};
	
	self.updateSpeedComponents = function (speed) {
		var radians = this.angle * Math.PI/180;
		if (speed !== undefined) {
			this.speed = speed;
		}
		this.speedX = Math.cos(radians) * this.speed;
		this.speedY = Math.sin(radians) * this.speed;
	};
	
	self.updatePos = function () {
		var fn = "updatePos" + this.movementType;
		if (this._move) {
			this[fn]();
		}
	};
	
	self.updatePosLinear = function () {
		var cnx = this.context;
		
		if (this.toX !== undefined) {
			if (this.moves > 0 ) {
				this.nextX = this.x + this.speedX;
				this.nextY = this.y + this.speedY;
				this.moves--;
			} else {
				this.nextX = this.toX;
				this.nextY = this.toY;
			}
		//The movement is generated by a vector
		} else if (this.angle !== undefined) {
			//this.updateSpeedComponents(this.speed - (this.speed * this.friction));
			
			this.nextX = this.x + this.speedX;
			this.nextY = this.y + this.speedY;
		}
		
	};
	
	self.applyNewPosition = function () {
		this.x = this.nextX;
		this.y = this.nextY;
	};
	
	Element.prototype = self;
	exports.Element = Element;
	
});